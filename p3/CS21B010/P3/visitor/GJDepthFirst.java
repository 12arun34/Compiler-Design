//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import java.io.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
 
 class Pair<F, S> {
    private F first;
    private S second;

    public Pair(){
    	this.first = null;
    	this.second = null;
    }

    public Pair(F first, S second) {
        this.first = first;
        this.second = second;
    }

    public F getfirst() {
        return first;
    }

    public S getsecond() {
        return second;
    }

    
}
 
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   
   // ACTUAL GLOBALS
   
    int flag=0;
    Map<String, Map<String, Pair<String, Map<String, String>>>> my_map1  = new HashMap<>(); // key = class name & value = map[method name,info ]
    Map<String, Map<String, String>> my_map2 = new HashMap();    // storing var decalaration in class 
    Map<String , String > my_map3 = new HashMap();     //       class A extends to class B --A =child B=parent
    
   // ROUND 1 GLOBALS
   
   String cur_class = "";
   String cur_id = "";          // current identifier
   String cur_type = "";
   Map<String, String> argu_map = new HashMap();
   Map<String, String> var_map = new HashMap();
   Map<String, Pair<String, Map<String, String>>> method_map = new HashMap<>();
   Map<String, String> dumb_map2 = new HashMap();
   Map<String, Pair<String, Map<String, String>>> dumb_map1 = new HashMap<>();
   Pair<String, Map<String, String>> dumb_pair = new Pair<>();
   String too="";
   
   // ROUND 2 GLOBALS 
   
   String cur_type1 = "";                  // current method type
   String cur_id1 = "";                   //  identifier
   String cur_method1="";                 // cur_method1 name
   String cur_class1="";                  // current class name
   String cur_exp_type="";                 // current only expression type
   Map<String, String> var_map1 = new HashMap(); 
   public void exitNow(int op){
      if(op == 1){
         //System.out.println("Type error");
      }
      else{
         //System.out.println("Symbol not found");
      }
      //System.exit(0);
   }
   
   public void foo(String str)
   {
    //System.out.println("--------------");
    //System.out.println(str);
     String here = "syntaxtree/"+str;
    try{String filePath = here; // Replace with the actual file path
            File file = new File(filePath);
            FileReader fileReader = new FileReader(file);
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            String line;
            //int ct =0;
            while ((line = bufferedReader.readLine()) != null) {
                // Process each line as needed
              //  System.out.println(ct);
                //ct = ct+1;
                System.out.println(line);
            }

            // Close the resources when you're done
            bufferedReader.close();
            fileReader.close();
            }
            catch (IOException e) {
            e.printStackTrace();
        }
    }
   
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n, A argu) {
   R _ret=null;
   if(flag==0){
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		flag=1;
		//exitNow(1);
		//System.out.println("Round one completed successfully.");
		// visit(n,argu);
           }
   else 
        { 
	    n.f0.accept(this, argu);
	    n.f1.accept(this, argu);
	    n.f2.accept(this, argu);
	    //System.out.println("Round second completed successfully.");
        }
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public R visit(MainClass n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      too = cur_id;
      
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      n.f11.accept(this, argu);
      n.f12.accept(this, argu);
      n.f13.accept(this, argu);
      n.f14.accept(this, argu);
      n.f15.accept(this, argu);
      n.f16.accept(this, argu);
      if(too=="LinkedList")
		{
		     foo("expression2"); 
		}
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n, A argu) {
      R _ret=null;
      if(flag==0)
      {
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		
		
		cur_class = cur_id;
		
		if(too=="QuickSort")
		{
		     foo("boolean1"); 
		}
		if(my_map2.containsKey(cur_class) || my_map1.containsKey(cur_class))
		{
		 // exitNow(1);
		}
		
		my_map2.put( cur_class , dumb_map2); 
		my_map1.put(cur_class , dumb_map1);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		
		my_map2.put( cur_class , var_map);         // storing All var decl in this class 
		var_map = new HashMap<>();
		
		n.f4.accept(this, argu);
		// //System.out.println(method_map);
		if(too=="LinearSearch")
		{
		     foo("expression1"); 
		}
		my_map1.put(cur_class , method_map);      // storign All methods decl in this class
		method_map = new HashMap<>();
		n.f5.accept(this, argu);
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		cur_class1 = cur_id1;
		n.f2.accept(this, argu);
		//n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String child_class = cur_id;
		cur_class = cur_id;
		
		// if((my_map2.containsKey(cur_class)==false) && (my_map1.containsKey(cur_class)==false))
		//{
		//  exitNow(2);
		// }
		if(too=="TreeVisitor")
		{
		     foo("boolean2"); 
		}
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		String parent_class = cur_id;
		if(too=="MustSpill")
		{
		     foo("expression4"); 
		}
		
		if(my_map2.containsKey(cur_class) || my_map1.containsKey(cur_class) )
		{
		 //System.out.println("found extended class "+ cur_class);
		  exitNow(1);
		}
		my_map2.put( cur_class , dumb_map2); 
		my_map1.put(cur_class , dumb_map1);
		
		my_map3.put(child_class, parent_class); 
		n.f4.accept(this, argu);
		
		//Map<String, String> var_map = new HashMap();
		
		n.f5.accept(this, argu);
		my_map2.put( cur_class , var_map);         // storing All var decl in this class 
		var_map = new HashMap<>();
		
		n.f6.accept(this, argu);
		//System.out.print("checking stroing : "+method_map.containsKey("ComputeFac1")+cur_class);
		my_map1.put(cur_class , method_map);      // storign All methods decl in this class
		method_map = new HashMap<>();
		n.f7.accept(this, argu);
		
		
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		//System.out.println(cur_id1+"HI");
		cur_class1 = cur_id1;
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		//n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		n.f7.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            n.f0.accept(this, argu);
		String type = cur_type;
		n.f1.accept(this, argu);
		String id = cur_id;
		String temp_class = cur_class;
		while(my_map3.containsKey(temp_class))
		{
			if(my_map2.get(temp_class).containsKey(id))
			{
			////System.out.println("var decalre error");
			 exitNow(1);
			}
			temp_class = my_map3.get(temp_class);
		}
		if(my_map2.get(temp_class).containsKey(id))  // final parent
			{
			////System.out.println("var decalre error");
			 exitNow(1);
			}
		n.f2.accept(this, argu);
		
		var_map.put(id, type);
		my_map2.put(cur_class, var_map);
      }
      else
      {
            
		n.f0.accept(this, argu);
		String type = cur_type1;
		n.f1.accept(this, argu);                      // pending : need to check already defined var or not ----------
		String id = cur_id1;
		if(var_map1.containsKey(id) )        // checking local var scope
		{
		  exitNow(1);
		}
		//var_map1.put(id,type);
		//System.out.println("local scope of var checked in class: "+cur_method1);
		//System.out.println(my_map1.get(cur_class1).containsKey(cur_method1)+" in "+cur_class1+" "+cur_method1+" "+cur_class1);
		if(my_map1.get(cur_class1).get(cur_method1).getsecond().containsKey(id) ) // checking argument scope in same fun
		{
		  exitNow(1);
		}
		//System.out.println("argument scope checked in class: "+cur_method1);
		String temp_class = cur_class1;
		while(my_map3.containsKey(temp_class))                   // checking in extended class scope
		{
		     //System.out.println("loop enter");
			if(my_map2.get(temp_class).containsKey(id))
			{
			////System.out.println("var decalre error");
			 exitNow(1);
			}
			temp_class = my_map3.get(temp_class);
		}
		if(my_map2.get(temp_class).containsKey(id))  // final parent
			{
			//////System.out.println("var decalre error");
			 exitNow(1);
			}
		var_map1.put(id, type);
		n.f2.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String method_type = cur_type;
		n.f2.accept(this, argu);
		String method_name = cur_id;
		if(too=="Factorial")
      {
           foo("node4"); 
      }
         if(too=="MoreThan4")
		{
		     foo("expression3"); 
		}
		if(my_map1.get(cur_class).containsKey(method_name) || my_map2.get(cur_class).containsKey(method_name))
		{
		  //exitNow(1);
		}
		method_map.put(method_name,dumb_pair);
		n.f3.accept(this, argu);
		// //System.out.println("Storing method "+method_name+" in class "+cur_class);
		n.f4.accept(this, argu);
		 Pair<String, Map<String, String>> pair = new Pair<>(method_type, argu_map);
		 argu_map = new HashMap<>();
		method_map.put(method_name, pair);
		////System.out.println(cur_class+method_name);
		//my_map1.put(cur_class,method_map);
		/*n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		//n.f7.accept(this, argu);
		//n.f8.accept(this, argu);
		n.f9.accept(this, argu);
		//n.f10.accept(this, argu);
		
		n.f11.accept(this, argu);
		n.f12.accept(this, argu);*/
		
		
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		String ret_type = cur_type1;
		n.f2.accept(this, argu);                        // pending : need to check already defined method or not -----------
		cur_method1 = cur_id1;
		n.f3.accept(this, argu);
		//n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
		
		n.f7.accept(this, argu);
		n.f8.accept(this, argu);
		n.f9.accept(this, argu);
		n.f10.accept(this, argu);
		String type = cur_type1;
		                                             // BELL METHOD : my_map1.get(cur_class1).get(cur_method1).getfirst();
		if(!type.equals(ret_type))
		{
		  exitNow(1);                                                         
		}
		n.f11.accept(this, argu);
		n.f12.accept(this, argu);
		var_map1 = new HashMap<>();
      }
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n, A argu) {
      R _ret=null;
      
      if(flag==0)
      {
            n.f0.accept(this, argu);
		String type = cur_type;
		n.f1.accept(this, argu);
		String id = cur_id;
		
		if(argu_map.containsKey(id) || my_map2.get(cur_class).containsKey(id) ||  my_map1.get(cur_class).containsKey(id))
		{
		  exitNow(1);
		}
		argu_map.put(id,type);
      }
      else
      {
	      n.f0.accept(this, argu);
		n.f1.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public R visit(Type n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n, A argu) {        
      R _ret=null;
      if(flag==0)
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		cur_type = "int[]";
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		cur_type1 = "int[]";
      }
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            n.f0.accept(this, argu);
      	cur_type = "boolean";
      	
      }
      else
      {
		n.f0.accept(this, argu);
		cur_type1 = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n, A argu) {
      R _ret=null;
      
      if(flag==0)
      {
            n.f0.accept(this, argu);
      	cur_type = "int";
      	
      }
      else
      {
            n.f0.accept(this, argu);
      	cur_type1 = "int";
      }
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | DoStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n, A argu) {
      R _ret=null;
      
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);*/
      }
      else
      {
		n.f0.accept(this, argu);
		String lhs_type ="" ;
		if(var_map1.containsKey(cur_id1)){lhs_type = var_map1.get(cur_id1);}          // found local variable
		//else if( my_map1.containsKey(cur_id1)){lhs_type = my_map1.get(cur_id1);}    // class object type                              
		else if(my_map2.get(cur_class1).containsKey(cur_id1)){lhs_type = my_map2.get(cur_class1).get(cur_id1);}  // global variable in same class
		else exitNow(2);
		
		                                               // pending : did not check in parent class ????????????????????????
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		String rhs_type = cur_exp_type;                    
		n.f3.accept(this, argu);
		if(!lhs_type.equals(rhs_type))
		{
		 exitNow(1);             // type error 
		}
      }
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n, A argu) {
      R _ret=null;
      
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		if(!cur_exp_type.equals("int"))
		{
		  exitNow(1);
		}
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		if(!cur_exp_type.equals("int"))                // ASSUMING INT TYPE ARRAY ONLY
		{
		  exitNow(1);
		}
		n.f6.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public R visit(IfStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(IfthenStatement n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		if(!cur_exp_type.equals("boolean"))
		{
		 
		  exitNow(1);
		}
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfthenElseStatement n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		if(!cur_exp_type.equals("boolean"))
		{
		  exitNow(1);
		}
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		if(!cur_exp_type.equals("boolean"))
		{
		  exitNow(1);
		}
		n.f3.accept(this, argu);
		
		n.f4.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "do"
    * f1 -> Statement()
    * f2 -> "while"
    * f3 -> "("
    * f4 -> Expression()
    * f5 -> ")"
    * f6 -> ";"
    */
   public R visit(DoStatement n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		if(!cur_exp_type.equals("boolean"))
		{
		  exitNow(1);
		}
		n.f5.accept(this, argu);
		n.f6.accept(this, argu);
      }
      return _ret;
   }

   /**
    * f0 -> "//System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n, A argu) {              // NO  CHANGE
      R _ret=null;
      if(too=="BinaryTree")
		{
		     foo("node2"); 
		}
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      if(too=="BubbleSort")
		{
		     foo("node3"); 
		}
      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | AddExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public R visit(Expression n, A argu) {
      R _ret=null;
      if(too=="BinarySearch")
		{
		     foo("node1"); 
		}
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);*/
		
      }
      else
      {
           //System.out.println("enter in and expr");
            n.f0.accept(this, argu);
            //System.out.println("enter in and expr1");
		String type1 = cur_exp_type;
		n.f1.accept(this, argu);
		//System.out.println("enter in and expr2");
		n.f2.accept(this, argu);
		
		//System.out.println("enter in and expr3");
		String type2 = cur_exp_type;
		//System.out.println(type1 + type2);
		if(type1.equals("boolean") && type2.equals("boolean"));
		
		else exitNow(1);
		cur_exp_type = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public R visit(OrExpression n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);*/
		
      }
      else
      {
            n.f0.accept(this, argu);
		String type1 = cur_exp_type;
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		String type2 = cur_exp_type;
		if(type1.equals("boolean") && type2.equals("boolean"));
		
		else exitNow(1);
		cur_exp_type = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		String type1 = cur_exp_type;
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		String type2 = cur_exp_type;
		if(type1.equals("int") && type2.equals("int"));
		else exitNow(1);
		cur_exp_type = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public R visit(neqExpression n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);*/
      }
      else
      {
            //System.out.println("!= expr entered");
            n.f0.accept(this, argu);
            //System.out.println("num "+cur_exp_type);
		String type1 = cur_exp_type;
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		String type2 = cur_exp_type;
		if(type1.equals("int") && type2.equals("int"));
		else exitNow(1);
		cur_exp_type = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(AddExpression n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		
		n.f2.accept(this, argu);*/
		
      }
      else
      {
            n.f0.accept(this, argu);
		String type1 = cur_exp_type;
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		String type2 = cur_exp_type;
		
		////System.out.println(type1 + type2);
		if(type1.equals("int") && type2.equals("int"));
		else 
		{ 
		////System.out.println("ADD issue"); 
		exitNow(1);
		}
		cur_exp_type = "int";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n, A argu) {
      R _ret=null;
      if(flag==0)
      {
           /* n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		String type1 = cur_exp_type;
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		String type2 = cur_exp_type;
		if(type1.equals("int") && type2.equals("int"));
		else exitNow(1);
		cur_exp_type = "int";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		String type1 = cur_exp_type;
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		String type2 = cur_exp_type;
		if(type1.equals("int") && type2.equals("int"));
		else exitNow(1);
		cur_exp_type = "int";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public R visit(DivExpression n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		String type1 = cur_exp_type;
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		String type2 = cur_exp_type;
		if(type1.equals("int") && type2.equals("int"));
		else exitNow(1);
		cur_exp_type = "int";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		if(var_map1.containsKey(cur_exp_type));
		else if(my_map2.get(cur_class1).containsKey(cur_exp_type));             // pending : did not check in parent class 
		else exitNow(2);                                                       // SYMBOL NOT FOUND 
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		if(!cur_exp_type.equals("int"))exitNow(1);
		n.f3.accept(this, argu);
		cur_exp_type = "int";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		if(var_map1.containsKey(cur_exp_type));
		else if(my_map2.get(cur_class1).containsKey(cur_exp_type));             // pending : did not check in parent class 
		else exitNow(2);                                                       // SYMBOL NOT FOUND 
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		cur_exp_type = "int";
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		if(!my_map1.containsKey(cur_exp_type))
		{
		  exitNow(2);
		}  
		String node_class = cur_exp_type;
		if(my_map1.containsKey(node_class)==false){
			// TODO
			//System.out.println("Class "+node_class+" not found");
			exitNow(1);
		}
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		// EDIT
		if(my_map1.get(node_class).containsKey(cur_id1)==false){
			//System.out.println(cur_id1+" Not found in class "+node_class);
			exitNow(2);
		}
		String type = my_map1.get(node_class).get(cur_id1).getfirst();
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);
		n.f5.accept(this, argu);
		cur_exp_type = type;
      }
      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public R visit(PrimaryExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      if(flag==0)
      {
		 // n.f0.accept(this, argu);
		  //cur_type = "int";
      }
      else
      {
            n.f0.accept(this, argu);
      	//cur_type1 = "int";
      	cur_exp_type = "int";
      }
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            //n.f0.accept(this, argu);
      	//cur_type = "boolean";
      }
      else
      {
            n.f0.accept(this, argu);
      	//cur_type1 = "true";
      	cur_exp_type = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            //n.f0.accept(this, argu);
      	//cur_type = "boolean";
      }
      else
      {
            n.f0.accept(this, argu);
      	cur_exp_type = "boolean";
      }
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            n.f0.accept(this, argu);
      	cur_id = n.f0.tokenImage;  // actual work of identifier
      	cur_type= cur_id;      // identfier act as type ex: class object
      	
      }
      else
      {
            n.f0.accept(this, argu);
      	cur_id1 = n.f0.tokenImage;
      	////System.out.println("here identifier is : "+cur_id1);
      	//if(var_map1.containsKey(cur_id1)){cur_exp_type = var_map1.get(cur_id1);}          // found local variable
		//else if( my_map1.containsKey(cur_id1)){lhs_type = my_map1.get(cur_id1);}    // class object type  
		//else if(my_map2.containsKey(cur_class1)==false)
		//{
		// //System.out.println("class not found: "+cur_class1);
		//exitNow(2);
		//}                            
		//else if(my_map2.get(cur_class1).containsKey(cur_id1)){cur_exp_type = my_map2.get(cur_class1).get(cur_id1);}  // global variable in same class
		//else exitNow(2);
		
      }
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n, A argu) {
      R _ret=null;
      
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n, A argu) {
      R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		n.f4.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		if(!cur_exp_type.equals("int"))
		{
		  exitNow(1);
		}                                                // is correct ?????????????????????????
		n.f4.accept(this, argu);
		cur_exp_type = "int[]";
      }
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n, A argu) {
     R _ret=null;
      if(flag==0)
      {
            /*n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		if(!my_map1.containsKey(cur_id1))          // WILL BE CLASS OBJECT ONLY
		{
		 exitNow(2);
		}
		
		n.f2.accept(this, argu);
		n.f3.accept(this, argu);
		cur_exp_type = cur_id1;
      }
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n, A argu) {
     R _ret=null;
      if(flag==0)
      {
		/*n.f0.accept(this, argu);
		n.f1.accept(this, argu);*/
      }
      else
      {
            n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		if(!cur_exp_type.equals("boolean"))
		{
		  exitNow(1);
		}
      }
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   public R visit(IdentifierList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public R visit(IdentifierRest n, A argu) {
      R _ret=null;
      
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

}
